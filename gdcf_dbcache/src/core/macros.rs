macro_rules! table {
    ($model: ident => $table: ident {$($model_field: ident => $table_column: ident),*; $($unmapped_column: ident),*}) => {
        pub mod $table {
            use super::$model;
            use core::backend::Error;
            use core::query::insert::Insertable;
            use core::query::select::{Queryable, Row};
            use core::table::{Field, Table, SetField};

            #[allow(non_upper_case_globals)]
            pub const table_name: &str = stringify!($table);

            $(
                #[allow(non_upper_case_globals)]
                pub static $table_column: Field = Field {
                    table: table_name,
                    name: stringify!($table_column)
                };
            )*

            $(
                #[allow(non_upper_case_globals)]
                pub static $unmapped_column: Field = Field {
                    table: table_name,
                    name: stringify!($unmapped_column)
                };
            )*

            #[allow(non_upper_case_globals)]
            pub static table: Table = Table {
                name: table_name,
                fields: &[
                    $(&$table_column,)*
                    $(&$unmapped_column,)*
                ]
            };

            #[cfg(feature = "pg")]
            mod pg {
                use core::backend::pg::Pg;
                use super::*;

                __insertable!(Pg, $model, $($model_field => $table_column,)*);
                __queryable!(Pg, $model, $($model_field,)*);
            }

            #[cfg(feature = "sqlite")]
            mod pg {
                use core::backend::sqlite::Sqlite;
                use super::*;

                __insertable!(Sqlite, $model, $($model_field => $table_column,)*);
                __queryable!(Sqlite, $model, $($model_field,)*);
            }

            #[cfg(feature = "mysql")]
            mod pg {
                use core::backend::mysql::MySql;
                use super::*;

                __insertable!(MySql, $model, $($model_field => $table_column,)*);
                __queryable!(MySql, $model, $($model_field,)*);
            }
        }
    };
}


macro_rules! __insertable {
    ($backend: ty, $model: ty, $($model_field: ident => $table_column: ident),*,) => {
        impl Insertable<$backend> for $model {
            fn table(&self) -> &Table {
                &table
            }

            fn values(&self) -> Vec<SetField<$backend>> {
                vec![
                    $(
                        $table_column.set(&self.$model_field)
                    ),*
                ]
            }
        }
    };
}

macro_rules! __queryable {
    (@[$(($idx: expr, $model_field: ident))*], $next_idx: expr, $backend: ty, $model: ident,) => {
        impl Queryable<$backend> for $model {
            fn from_row(row: &Row<$backend>, offset: isize) -> Result<Self, Error<$backend>> {
                Ok($model {
                    $(
                        $model_field: row.get(offset + $idx).expect("In code generated by table! macro. Did you define your schema correctly?")?,
                    )*
                })
            }
        }
    };

    (@[$(($idx: expr, $model_field: ident))*], $next_idx: expr, $backend: ty, $model: ident, $current: ident, $($rest: ident),*$(,)?) => {
        __queryable!(@[
            $(($idx, $model_field))*
            ($next_idx, $current)
        ], $next_idx + 1, $backend, $model, $($rest,)*);
    };

    ($backend: ty, $model: ident, $($rest: ident),*,) => {
        __queryable!(@[], 0, $backend, $model, $($rest,)*);
    };
}


macro_rules! if_query_part {
    ($t: ty, $tr: ty) => {
        impl<'a, DB: Database> $tr for $t
            where
                $t: QueryPart<DB>
        {}
    };
}

macro_rules! simple_query_part {
    ($back: ty, $t: ty, $val: expr) => {
        impl QueryPart<$back> for $t {
            fn to_sql_unprepared(&self) -> String {
                String::from($val)
            }
        }
    };
}

macro_rules! create {
    ($model: ident, @[], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [],
            [$(($t, $bound))*],
            [$($stack_tokens)*, ($column, $sql_type, [])],
            $($rest)*
        );
    };

    ($model: ident, @[$($constraint: expr),*$(,)?], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident[] => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [],
            [$(($t, $bound))*],
            [$($stack_tokens)*, ($column, $sql_type, [$($constraint,)*])],
            $($rest)*
        );
    };

    ($model: ident, @[$($constraint: expr),*$(,)?], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident[NotNull $(,$($cons_tokens: tt)*)?] => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [NotNullConstraint::default(), $($constraint,)*],
            [(NotNullConstraint<'a>, Constraint<DB>) $(($t, $bound))*],
            [$($stack_tokens)*],
            $column[$($($cons_tokens)*)?] => $sql_type, $($rest)*
        );
    };

    ($model: ident, @[$($constraint: expr),*$(,)?], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident[Unique $(,$($cons_tokens: tt)*)?] => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [UniqueConstraint::default(), $($constraint,)*],
            [(UniqueConstraint<'a>, Constraint<DB>) $(($t, $bound))*],
            [$($stack_tokens)*],
            $column[$($($cons_tokens)*)?] => $sql_type, $($rest)*
        );
    };

    ($model: ident, @[$($constraint: expr),*$(,)?], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident[Primary $(,$($cons_tokens: tt)*)?] => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [PrimaryKeyConstraint::default(), $($constraint,)*],
            [(PrimaryKeyConstraint<'a>, Constraint<DB>) $(($t, $bound))*],
            [$($stack_tokens)*],
            $column[$($($cons_tokens)*)?] => $sql_type, $($rest)*
        );
    };

    ($model: ident, @[$($constraint: expr),*$(,)?], [$(($t: ty, $bound: path))*], [$($stack_tokens: tt)*], $column: ident[Default<$dt: ty>($value: expr) $(,$($cons_tokens: tt)*)?] => $sql_type: ty, $($rest: tt)*) => {
        create!($model,
            @
            [DefaultConstraint::new(None, $value), $($constraint,)*],
            [(DefaultConstraint<'a, DB, $dt>, Constraint<DB>) ($dt, SqlExpr<DB>) $(($t, $bound))*],
            [$($stack_tokens)*],
            $column[$($($cons_tokens)*)?] => $sql_type, $($rest)*
        );
    };

    ($model: ident, @[], [$(($t: ty, $bound: path))*], [,$(($column: ident, $sql_type: ty, [$($constraint: expr),* $(,)?])),*], ) => {
        use core::types::*;
        use core::query::create::*;
        #[allow(unused_imports)]
        use core::*;
        use core::backend::Database;

        pub fn create<'a, DB: Database + 'a>() -> Create<'a, DB>
            where
                $(
                    $t: $bound + 'static,
                )*
                $(
                    $sql_type: Type<DB>,
                )*
        {
            $model::table.create()
            $(
                .with_column(Column::new($model::$column.name(), {let ty: $sql_type = Default::default(); ty})
                    $(
                        .constraint($constraint)
                    )*
                )
            )*
        }
    };

    ($model: ident, @$($tokens: tt)*) => {
        compile_error!("You fucked up, good luck fixing it");
    };

    ($model: ident, $($tokens: tt)*) => {
        create!($model, @[], [], [], $($tokens)*,);
    };
}