macro_rules! table {
    ($model: ident => $table: ident {$($model_field: ident => $table_column: ident[$sql_type: ty $(,$($cons: tt),*)?]),*; $($unmapped_column: ident[$sql_type2: ty $(,$($cons2: tt),*)?]),*}) => {
        pub(crate) mod $table {
            use super::$model;
            use core::backend::{Database, Error};
            use core::query::create::*; // we need all the constraints
            use core::query::insert::Insertable;
            use core::query::select::{Queryable, Row};
            use core::table::{Field, Table, SetField};
            use core::types::*;

            #[allow(non_upper_case_globals)]
            pub(crate) const table_name: &str = stringify!($table);

            $(
                #[allow(non_upper_case_globals)]
                pub(crate) static $table_column: Field = Field {
                    table: table_name,
                    name: stringify!($table_column)
                };
            )*

            $(
                #[allow(non_upper_case_globals)]
                pub(crate) static $unmapped_column: Field = Field {
                    table: table_name,
                    name: stringify!($unmapped_column)
                };
            )*

            #[allow(non_upper_case_globals)]
            pub(crate) static table: Table = Table {
                name: table_name,
                fields: &[
                    $(&$table_column,)*
                    $(&$unmapped_column,)*
                ]
            };

            #[cfg(feature = "pg")]
            mod pg {
                use core::backend::pg::Pg;
                use super::*;

                __insertable!(Pg, $model, $($model_field => $table_column,)*);
                __queryable!(Pg, $model, $($model_field,)*);
            }

            #[cfg(feature = "sqlite")]
            mod pg {
                use core::backend::sqlite::Sqlite;
                use super::*;

                __insertable!(Sqlite, $model, $($model_field => $table_column,)*);
                __queryable!(Sqlite, $model, $($model_field,)*);
            }

            #[cfg(feature = "mysql")]
            mod pg {
                use core::backend::mysql::MySql;
                use super::*;

                __insertable!(MySql, $model, $($model_field => $table_column,)*);
                __queryable!(MySql, $model, $($model_field,)*);
            }

            pub(crate) fn create<'a, DB: Database + 'a>() -> Create<'a, DB>
                where
                    $($sql_type: Type<'a, DB>,)*
                    $($sql_type2: Type<'a, DB>,)*
                    $($($(__constraint_type!($cons): Constraint<'a, DB> + 'static,)*)?)*
                    $($($(__constraint_type!($cons2): Constraint<'a, DB> + 'static,)*)?)*
            {
                Create::new(table_name)
                $(
                    .with_column(
                        __constraints!(Column::new($table_column.name(), {
                            let ty: $sql_type = Default::default();
                            ty
                        }), $($($cons,)*)?)
                    )
                )*
                $(
                    .with_column(
                        __constraints!(Column::new($unmapped_column.name(), {
                            let ty: $sql_type2 = Default::default();
                            ty
                        }), $($($cons2,)*)?)
                    )
                )*
            }
        }
    };
}

macro_rules! __constraint_type {
    (NotNull) => {
        NotNullConstraint<'a>
    };
}

macro_rules! __constraints {
    ($column: expr, NotNull, $($rest: tt),*) => {
        __constraints!($column.not_null(), $($rest,)*)
    };

    ($column: expr, $invalid: tt, $($rest: tt),*) => {
        compiler_error!("Invalid constraint start")
    };

    ($column: expr, ) => {
        $column
    };
}

macro_rules! __insertable {
    ($backend: ty, $model: ty, $($model_field: ident => $table_column: ident),*,) => {
        impl Insertable<$backend> for $model {
            fn table<'a>(&'a self) -> &'a Table {
                &table
            }

            fn values(&self) -> Vec<SetField<$backend>> {
                vec![
                    $(
                        $table_column.set(&self.$model_field)
                    ),*
                ]
            }
        }
    };
}

macro_rules! __queryable {
    (@[$(($idx: expr, $model_field: ident))*], $next_idx: expr, $backend: ty, $model: ident,) => {
        impl Queryable<$backend> for $model {
            fn from_row(row: &Row<$backend>, offset: isize) -> Result<Self, Error<$backend>> {
                Ok($model {
                    $(
                        $model_field: row.get(offset + $idx).expect("In code generated by table! macro. Did you define your schema correctly?")?,
                    )*
                })
            }
        }
    };

    (@[$(($idx: expr, $model_field: ident))*], $next_idx: expr, $backend: ty, $model: ident, $current: ident, $($rest: ident),*$(,)?) => {
        __queryable!(@[
            $(($idx, $model_field))*
            ($next_idx, $current)
        ], $next_idx + 1, $backend, $model, $($rest,)*);
    };

    ($backend: ty, $model: ident, $($rest: ident),*,) => {
        __queryable!(@[], 0, $backend, $model, $($rest,)*);
    };
}